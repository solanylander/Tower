	#print("final", self.collide(False))
	# When the agent is hanging on an edge over its center of gravity it should tip in that direction
	def fallRotation(self, pivot, left):



		parts = self.parts
		# X,Y distances between the agents point of contact with the world and the agents main pivot point.
		# (The pivot is where the agent bases all calculations from and is the rotation point for its back)
		distanceXY = None
		# Torque is the distance the agents center of gravity is from the collision point being used
		torque = None
		# If the agent is falling to the left use the left most collision point otherwise use the rightmost
		if left:
			distanceXY = (self.box[0][0] - parts[0].getPivot()[0], self.box[0][1] - parts[0].getPivot()[1])
			torque = (self.cog[0] - self.box[0][0]) / 25
		else:
			distanceXY = (self.box[1][0] - parts[0].getPivot()[0], self.box[1][1] - parts[0].getPivot()[1])
			torque = (self.cog[0] - self.box[1][0]) / 25

		# Actual distance between the agents point of contact with the world and the agents main pivot point
		distanceH = math.sqrt(distanceXY[0] * distanceXY[0] + distanceXY[1] * distanceXY[1])

		# The angle between the collision point being used and the agents pivot point. The agent will be rotated around the point of collision
		# since when you fall you fall around the last place you were touching the ground
		currentAngle = None
		if(distanceXY[0] == 0):
			currentAngle = 90
		else:
			currentAngle = math.atan(distanceXY[1]/distanceXY[0]) * 180.0 / math.pi


		# The X,Y distances between the agents point of contact with the world and where the agents main pivot point will be after the rotation
		newXY = (math.cos((180.0 + currentAngle + torque) / 180 * math.pi), -math.sin((currentAngle + torque) / 180 * math.pi))
		newXY = (-abs(newXY[0] * distanceH), -abs(newXY[1] * distanceH))
		# Difference between where the pivot point is and where it will be after the rotation
		if(distanceXY[0] < 0):	
			newXY = (distanceXY[0] - newXY[0], newXY[1])
		else:
			newXY = (distanceXY[0] + newXY[0], newXY[1])
		if(distanceXY[1] < 0):
			newXY = (newXY[0], newXY[1] - distanceXY[1])
		else:
			newXY = (newXY[0], newXY[1] + distanceXY[1])
		# Once the agent has successfully rotated without colliding with the world passed = True
		passed = False
		# Store a backup of the agent
		self.stored(True)
		# Keep attempting to rotate the agent whilst moving it slightly away from the point of contact. Since the agents legs do not have rounded edges sometimes its
		# corner will get stuck in the ground so this gives it a little room to work with
		for horizontal in range(0,1):
			# Move vertically first since this will be negated by gravity and only move horizontally if necessary
			for vertical in range(0,5):
				# Move slightly left if the agent is falling to the left otherwise move slightly right, also move up
				if left:
					newPivot = (pivot[0] + newXY[0] - (0.3 * horizontal), pivot[1] + newXY[1] - (0.5 * vertical))
				else:
					newPivot = (pivot[0] + newXY[0] + (0.3 * horizontal), pivot[1] + newXY[1] - (0.5 * vertical))
				# Move and rotate the agent
				self.rotateAll(-torque)
				self.setPositions(newPivot)
				# If the agent collides with the world reset it with the stored values otherwise finish iterating and break
				if self.collide(1):
					self.stored(False)
				else:
					passed = True
					break
			if passed:
				self.stored(True)
				return newPivot, vertical
		return pivot, 0
